{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Unlogged Java Tool","text":"<p>Use Unlogged-SDK with your Java applications and gain unparalleled insights into your application runtime behavior and unlock a plethora of new capabilities.</p>"},{"location":"#live-view","title":"Live view","text":"<ul> <li>Gain timed traces of all executed methods</li> <li>Access return values for every method call</li> <li>Monitor time spent on each line of code</li> <li>Live coverage tracking for comprehensive analysis</li> </ul>"},{"location":"#real-time-call-mocking","title":"Real time call mocking","text":"<p>Effortlessly mock any downstream call within your running application. Our \"Always Available\" live mocking feature eliminates the need for containers or services, allowing seamless integration into your development workflow. Save mock definitions as JSON files, ensuring consistency across your team.</p> <p></p>"},{"location":"#replay-testing","title":"Replay testing","text":"<p>Capture application traffic as replay tests and seamlessly trigger them within your CI pipeline using mvn test. Ensure the reliability of idempotent methods and safeguard against regressions.</p> <ul> <li>Unit replay tests: leverage custom mocks for precise testing</li> <li>Integration replay tests: validate end-to-end functionality</li> <li>Failure replay tests: fortify failing cases to ensure consistent results</li> </ul> <p></p>"},{"location":"#automated-junit-test-generation","title":"Automated JUnit Test generation","text":"<p>Automate test script generation with JUnit, utilizing replay tests or generating boilerplate code to kickstart your testing efforts. Seamlessly integrate with Mockito for efficient test dependency management.</p> <p>Unlock the potential of automated testing with Unlogged, streamlining your development process and ensuring the reliability and performance of your Java applications.</p> <p>Install Unlogged, record and replay java methods, track code coverage, mock external and downstream calls, and create perfectly working JUnit tests. </p>"},{"location":"analytics/","title":"What do we track?","text":"<p>Unlogged tracks a few things from the plugin. This is important for us to improve the developer experience and release better products.</p> <p>Here are a few things we track.</p>"},{"location":"analytics/#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Computer Hostname</li> <li>SDK Connection</li> <li>Method Invocation</li> <li>SDK Responses</li> <li>Test Case Generation</li> <li>Replay Features</li> <li>Mock Management</li> <li>Replay Status Insights</li> <li>Privacy Assurance</li> </ul>"},{"location":"analytics/#computer-hostname","title":"Computer Hostname","text":"<ul> <li>What We Track: Your computer's hostname.</li> <li>Why It Matters: This helps us gauge the user count and identify where users might encounter issues.</li> </ul>"},{"location":"analytics/#sdk-connection","title":"SDK Connection","text":"<ul> <li>Event Logging: Initiation of the application with Unlogged SDK.</li> <li>Purpose: To confirm your successful progression from installation to application startup.</li> </ul>"},{"location":"analytics/#method-invocation","title":"Method Invocation","text":"<ul> <li>Focus: Name of the method invoked.</li> <li>Note: Rest assured, we do not track the method's input variables or its return values.</li> </ul>"},{"location":"analytics/#sdk-responses","title":"SDK Responses","text":"<ul> <li>Two Key Events:</li> <li>SDK Response (Normal): Logged when methods return the expected object smoothly.</li> <li>SDK Response (Exception): Tracked if a method fails or returns an exception.</li> </ul>"},{"location":"analytics/#test-case-generation","title":"Test Case Generation","text":"<ul> <li>Tracking Instance: Generation of unit tests using recorded data.</li> <li>Impact: Enables us to refine this feature for your ease of use.</li> </ul>"},{"location":"analytics/#replay-features","title":"Replay Features","text":"<ul> <li>Key Actions Tracked:</li> <li>Candidate Replay: When you replay a candidate, it's noted.</li> <li>Replay Saving: Saving replays in JSON format is also tracked.</li> <li>Privacy Note: We do not monitor assertion rules, variable names in these rules, or the assertion JSON.</li> </ul>"},{"location":"analytics/#mock-management","title":"Mock Management","text":"<ul> <li>What We Observe: Injection, activation, or deactivation of mocks.</li> <li>Privacy Assurance: Details like mock maps or specific lines for mock operations are not tracked.</li> </ul>"},{"location":"analytics/#replay-status-insights","title":"Replay Status Insights","text":"<ul> <li>Insight Gathering: Whether a replay candidate passes or fails.</li> <li>Privacy Commitment: No tracking of variable names, code blocks, or config files.</li> </ul>"},{"location":"analytics/#privacy-assurance","title":"Privacy Assurance","text":"<ul> <li>Offline Functionality: Operates entirely offline.</li> <li>Non-Intrusive: No event tracking hinders your workflow.</li> <li>Data Integrity: Your code and configurations stay private.</li> </ul>"},{"location":"cirunner/","title":"Running the Replay Tests in CI","text":"<p>While running the replay tests locally is important during development for rapid feedback, using a CI pipeline  enhances the overall development process by automating the testing and validation steps in a controlled and scalable environment. It ensures that the codebase is reliable and meets quality standards before changes are pushed to production.</p>"},{"location":"cirunner/#adding-the-dependency","title":"Adding the dependency","text":"mavengradle <pre><code>&lt;dependency&gt;\n  &lt;artifactId&gt;unlogged-sdk&lt;/artifactId&gt;\n  &lt;groupId&gt;video.bug&lt;/groupId&gt;\n  &lt;version&gt;LATEST&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>dependencies\n{\n    implementation 'video.bug:unlogged-sdk:LATEST'\n    annotationProcessor 'video.bug:unlogged-sdk:LATES'\n}\n</code></pre>"},{"location":"cirunner/#replays-like-unit-tests","title":"Replays like unit tests","text":"<ul> <li>mock all the dependency calls inside your methods </li> <li>bind them with the replays. </li> </ul> <p>unlogged-sdk test runner uses the JUnit Platform test runner to run replays created using the plugin. To execute unlogged tests as <code>mvn test</code> or <code>gradle test</code> or <code>intellij run test</code>.</p> <p>Start by creating the following test class file <code>UnloggedTest.java</code> in your src/test/java directory</p> <pre><code>import io.unlogged.runner.UnloggedTestRunner;\nimport org.junit.runner.RunWith;\n\n@RunWith(UnloggedTestRunner.class)\npublic class UnloggedTest {\n\n}\n</code></pre> <p>Tip</p> <p>Yep! This class has no methods since the replay tests will be based on <code>src/test/resources/unlogged/&lt;ClassName&gt;.json</code> files.</p> <p>Execute <code>mvn test</code> or <code>gradle test</code> to execute the tests from CLI.</p>"},{"location":"cirunner/#integration-testing-on-springboot-application","title":"Integration testing on Springboot application","text":"<p>For Springboot applications, customize the above tests as follows:</p> <pre><code>@RunWith(UnloggedTestRunner.class)\n@ComponentScan(\"&lt;spring.application.package.name&gt;\")\n@EnableAutoConfiguration\n@PropertySource(\nvalue = {\"config/application.yml\", \"config/application-dev.yml\"},\nfactory = UnloggedRunnerTest.YamlPropertySourceFactory.class) \n@TestPropertySource({\"classpath:application.properties\"})\n@WebAppConfiguration\npublic class UnloggedRunnerTest {\n\n    public static class YamlPropertySourceFactory implements PropertySourceFactory {\n        public YamlPropertySourceFactory() {\n        }\n\n    @Override\n    public PropertiesPropertySource createPropertySource(String name, EncodedResource encodedResource) throws IOException {\n            YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();\n            factory.setResources(encodedResource.getResource());\n            return new PropertiesPropertySource(encodedResource.getResource().getFilename(), factory.getObject());\n       }\n    }\n}\n</code></pre> <p>Remember!</p> <p>Remember to update <code>&lt;spring.application.package.name&gt;</code> to your package name, <code>config/application-dev.yml</code> to the config files you want to use. <code>UnloggedRunnerTest.YamlPropertySourceFactory.class</code> is for supporting yml files. Specify your test application properties inside <code>ApplicationProperties.class</code>.</p> <p><code>WebAppConfiguration</code> annotation is needed if there are any methods in starting class of the project that configure services, that cannot be enabled for integration tests. For example some configuration for Swagger or API monitoring. If these configurations are in a seperate file, then the annotation is not needed.</p> <p>With this, unlogged test runner will create as instance of the spring application context and execute the tests based on the beans created by spring.</p>"},{"location":"cirunner/#reports","title":"Reports","text":"<p>Running <code>mvn test</code> or <code>gradle test</code> will generate <code>xml</code> reports that are stored at <code>${basedir}/target/surefire-reports</code></p>"},{"location":"commonerrors/","title":"Common Errors","text":""},{"location":"commonerrors/#direct-invoke","title":"Direct Invoke","text":"<p><code>DirectInvoke</code> communicates with your application using a custom RPC implementation inside the unlogged-sdk. The RPC is active when there is an <code>@Unlogged</code> annotation on the class executed.</p> <p>The RPC includes:</p> <ul> <li>Class name</li> <li>Method name</li> <li>Method signature</li> <li>Parameter types</li> <li>Paramter values</li> <li>Mock definitions</li> </ul> <p>The command executor in unlogged-sdk gets an instance of <code>ClassName</code>. It gets the instance in one of the two ways</p> <ul> <li>If available, use the last known instance of type ClassName</li> <li>If not, create a new one. </li> </ul> <p>Tip</p> <p>In case the command executor creates a new instance, it uses the no-arg constructor.</p>"},{"location":"commonerrors/#what-can-go-wrong","title":"What can go wrong?","text":""},{"location":"commonerrors/#object-serialization-and-deserialization","title":"Object Serialization and Deserialization","text":"<p>Unlogged converts an object to a <code>json</code> using a serializer and stores it bytestream. Later, we deserialize the object to a json. </p> <p>Object serialization/deserialization</p> <p>Unlogged uses jackson for serialization/deserialization.  If jackson is unable to serialize any parameter or return value then it shows up as its long id hash code. This can affect you while using DirectInvoke or Generate JUnit Test Case.</p>"},{"location":"commonerrors/#javalangnullpointerexception","title":"java.lang.NullPointerException","text":"<p>You may come across <code>NullPointerException</code> while using Direct Invoke. Here are possible explainations:</p>"},{"location":"commonerrors/#value-of-a-field-is-null","title":"Value of a field is null","text":"<p>When <code>Direct Invoke</code> is used on non-service classes so that no recently used instance is available - Unlogged creates a new instance of this class, using no-arg constructor. This means that a few feilds may be uninitialized. In this case, you will run into a <code>Null Pointer Exception</code></p>"},{"location":"commonerrors/#a-local-variable-based-on-input-parameter-is-null","title":"A local variable based on input parameter is null","text":"<p>Make sure the parameter values you are passing are correct and the associated data exists if downstream calls are not mocked.</p>"},{"location":"commonerrors/#cannot-invoke-javalangreflectfieldgettype-because-field-is-null","title":"Cannot invoke \"java.lang.reflect.Field.getType()\" because \"field\" is null","text":"<p>This means that one of the parameter required to execute the method could not be created. It could be due to different reasons.</p>"},{"location":"commonerrors/#authentication-is-empty","title":"Authentication is empty","text":"<p>When the method being executed expects an Object in the <code>SecurityContextHolder</code>, it will receive null and throw an NPE if it tries to invoke a method on the expected return object. </p>"},{"location":"commonerrors/#no-transaction-found","title":"No transaction found","text":"<p>When using <code>@Transacational</code> annotation on methods, currently the code using transactions will fail since no transaction is created when method are executed. </p> <p>Tip</p> <p>Support for <code>@Transacational</code> annotation, <code>SecurityContextHolder</code> and parameterized constructors is coming soon. </p>"},{"location":"coverage/","title":"Code Coverage","text":"<p>Getting code coverage number above 90% is often challenging and takes a lot of time and effort. Unlogged offers instant feedback on code coverage by highlighting  the lines of code executed. </p> <p></p> <p>The code coverage won't increase unless you save the candidates with assertions. </p> <p>Note the potential uptick  in the coverage number on the replay window.</p>"},{"location":"coverage/#tracking","title":"Tracking","text":"<p>You can check the progress in the tab <code>Code Coverage</code> every time you save different candidates.</p> <p>Track class coverage, method coverage and line coverage in this tab.</p> <p></p> <p>Tip</p> <p>The code coverage is shown even when you use external tools such as Postman, or Swagger to execute a method through an http end point.</p>"},{"location":"curiosity/","title":"How does this all work?","text":"<p>unlogged-sdk logs code execution and unlogged-plugin scans these logs and creates test candidates. </p>"},{"location":"curiosity/#unlogged-sdk","title":"Unlogged SDK","text":"<p>unlogged-sdk adds logging probes to the <code>java</code> code in compile time.</p> <p>We have extended lombok's implementation to add such probes automatically. </p> <p>Check our blog post that explains how lombok works </p>"},{"location":"curiosity/#unlogged-plugin","title":"Unlogged Plugin","text":""},{"location":"curiosity/#direct-invoke","title":"Direct Invoke","text":""},{"location":"curiosity/#scanning-logs","title":"Scanning Logs","text":""},{"location":"curiosity/#extracting-candidates","title":"Extracting Candidates","text":""},{"location":"curiosity/#mocking","title":"Mocking","text":""},{"location":"direct_invoke_java_method/","title":"Call Java Methods Directly","text":"<p>To test a <code>java</code> method, traditionally, you either have to write a unit test, or expose an http end point and then <code>F8</code>/step over  till you reach your method. A few folks often use <code>System.out.print</code> to debug. </p> <p>We connect a lot with this meme from monkeyuser</p> <p> </p>"},{"location":"direct_invoke_java_method/#direct-invoke","title":"Direct Invoke","text":"<p>With <code>Direct Invoke</code> you can call a Java method directly. Once you start your application in debug mode, you will see the cyan colored icon next to any method. Click on it and Unlogged pre-fills it with dummy arguments. Execute the method and you will get the return value just for the method you called.</p> <p></p>"},{"location":"direct_invoke_java_method/#debug-where-it-matters","title":"Debug where it matters","text":"<p>Start debugging where it matters. Put a breakpoint anywhere in the method and execute a method using <code>Direct Invoke</code>. Check IntelliJ's debugger and values of all variables.</p> <p>No need to expose an http end point or write a unit test to debug something deep within your code.</p> <p>Warning</p> <p>DO NOT call your <code>main</code> method using <code>Direct Invoke</code> It will fail since it attempts to start the process again using Unlogged with the same ports.</p>"},{"location":"direct_invoke_java_method/#what-can-you-do-with-a-replay","title":"What can you do with a replay?","text":"<ol> <li>Save and Push to Git: The replays are saved in the form of a json, inside your repository. You can push them to git and collaborate with your team memebers.</li> <li>Run them in CI: A simple <code>mvn test</code> or <code>./gradlew test</code> replays all replay tests. </li> <li>Get Code Coverage Report: Use surefire or any other reporting plugin to get code coverage reports with our replay tests.</li> <li>Maintain no extra code: Replays are saved in the form of a json and no extra generated code is added to your repository.</li> </ol> <p>Tip</p> <p>The replay tests automatically pick up the necessary mocks. </p>"},{"location":"generate_automated_junit/","title":"Generating JUnit Tests with Unlogged","text":"<p>With Unlogged.io, you have the capability to convert recordings of code execution into JUnit tests. This innovative feature is designed to streamline the testing process, making it more efficient and effective.</p>"},{"location":"generate_automated_junit/#how-does-it-work","title":"How Does It Work?","text":"<p>Unlogged.io tracks the execution of your code as it runs. This tracking captures all the necessary details of the code\u2019s behavior and outputs. Following the completion of code execution, Unlogged utilizes this recording to generate JUnit tests. </p> <p>These tests reflect the recorded execution path and outcomes, emulating real world scenarios.</p> <p></p> <p>Tip</p> <p>If generating JUnit tests post-execution does not align with your workflow, or if you prefer to set up tests in advance, Unlogged.io offers a boilerplate generation option. This feature allows you to create template-based tests before running your actual code. </p> <p>Here is how you can create boilerplate for your JUnit tests. </p> <p></p> <p>The <code>canDeliverToCustomer</code> method below determines if a delivery can be made to a customer based on their location and weather conditions:</p> <ol> <li>Fetch Customer Profile: Retrieves customer information using their ID.</li> <li>Extract Location: Converts the customer's address into a location format.</li> <li>Weather Check: Retrieves the weather for the customer's location.</li> <li>Check Delivery Unit Availability: Determines if any delivery units are available at the location.</li> <li>Delivery Decision:</li> <li>If no units are available, returns that delivery is not possible.</li> <li>Checks weather conditions (specifically precipitation) to decide if delivery is feasible.</li> <li>Report Generation: Writes a report based on the feasibility of delivery and returns the result with the customer profile and weather information.</li> </ol> <pre><code>    public DeliveryCheckResponse canDeliverToCustomer(long customerId) {\n        CustomerProfile customerProfile = customerProfileRepo.getByCustomerId(customerId);\n        String location = LocationUtils.getLocationFromAddress(customerProfile.getAddress());\n        WeatherInfo weatherInfo = weatherService.getWeatherForAddress(location);\n\n        List&lt;DeliveryUnit&gt; availableUnits = deliveryUnitService.getAvailableUnitsForLocation(\n                deliveryUnitService.getAllDeliveryUnits(), location);\n        if (availableUnits.size() == 0) {\n            return new DeliveryCheckResponse(customerProfile, false, false, weatherInfo);\n        }\n\n        boolean canDeliver = false;\n        if (weatherInfo.getCurrent().getPrecip_mm() &lt; 2.51) {\n            canDeliver = true;\n        }\n        boolean reportWritten = localFileService.writeReport(canDeliver, customerProfile);\n        return new DeliveryCheckResponse(customerProfile,\n                reportWritten, reportWritten &amp;&amp; canDeliver, weatherInfo);\n    } \n</code></pre> <p>Here is the JUnit Test generated for the code above:</p> <pre><code>   public final class TestDeliveryServiceV {\n\n    private DeliveryService deliveryService;\n    private CustomerProfileRepo customerProfileRepo;\n    private WeatherService weatherService;\n    private DeliveryUnitService deliveryUnitService;\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    @BeforeEach\n    public void setup() throws Exception {\n        customerProfileRepo = Mockito.mock(CustomerProfileRepo.class);\n        deliveryService = new DeliveryService();\n        injectField(deliveryService, \"customerProfileRepo\", customerProfileRepo);\n        weatherService = Mockito.mock(WeatherService.class);\n        deliveryUnitService = Mockito.mock(DeliveryUnitService.class);\n        injectField(deliveryService, \"weatherService\", weatherService);\n        injectField(deliveryService, \"deliveryUnitService\", deliveryUnitService);\n    }\n\n    @Test\n    public void testCanDeliverToCustomer() throws Exception {\n        CustomerProfile byCustomerId = objectMapper.readValue(\"{\\\"customerid\\\":4,\\\"customername\\\":\\\"ohn Doe\\\",\\\"dateofbirth\\\":\\\"70-10-20\\\",\\\"email\\\":\\\"JD@mail\\\",\\\"contactnumber\\\":\\\"999-999\\\",\\\"address\\\":\\\"304 Alainis Parkway, Boylemouth, Virginia\\\",\\\"referralcodes\\\":[\\\"JGSDFS, FEFWEF, FWEFDF\\\"],\\\"createdDate\\\":\\\"Apr 12, 2024 12:54:08 PM\\\",\\\"updatedDate\\\":\\\"Apr 12, 2024 12:54:08 PM\\\"}\", CustomerProfile.class);\n        Mockito.when(customerProfileRepo.getByCustomerId(eq(4L))).thenReturn(byCustomerId);\n\n        WeatherInfo weatherForAddress = objectMapper.readValue(\"{\\\"location\\\":{\\\"name\\\":\\\"Virginia Beach\\\",\\\"region\\\":\\\"Virginia\\\",\\\"country\\\":\\\"United States of America\\\",\\\"lat\\\":36.85,\\\"lon\\\":-75.98,\\\"tz_id\\\":\\\"America/New_York\\\",\\\"localtime_epoch\\\":1712906551,\\\"localtime\\\":\\\"2024-04-12 3:22\\\"},\\\"current\\\":{\\\"temp_c\\\":21.1,\\\"temp_f\\\":70.0,\\\"is_day\\\":0,\\\"condition\\\":{\\\"text\\\":\\\"Partly cloudy\\\",\\\"icon\\\":\\\"//cdn.weatherapi.com/weather/64x64/night/116.png\\\",\\\"code\\\":1003},\\\"wind_mph\\\":15.0,\\\"wind_kph\\\":24.1,\\\"wind_degree\\\":210,\\\"wind_dir\\\":\\\"SSW\\\",\\\"pressure_mb\\\":998.0,\\\"pressure_in\\\":29.48,\\\"precip_mm\\\":0.35,\\\"precip_in\\\":0.01,\\\"humidity\\\":84,\\\"cloud\\\":50,\\\"feelslike_c\\\":21.1,\\\"feelslike_f\\\":70.0,\\\"vis_km\\\":16.0,\\\"vis_miles\\\":9.0,\\\"uv\\\":1.0,\\\"gust_mph\\\":37.6,\\\"gust_kph\\\":60.5}}\", WeatherInfo.class);\n        Mockito.when(weatherService.getWeatherForAddress(eq(\"Virginia\"))).thenReturn(weatherForAddress);\n\n        List&lt;DeliveryUnit&gt; availableUnitsForLocation = objectMapper.readValue(\"[]\", new TypeReference&lt;List&lt;DeliveryUnit&gt;&gt;() {});\n        Mockito.when(deliveryUnitService.getAvailableUnitsForLocation(any(Object.class), eq(\"Virginia\"))).thenReturn(availableUnitsForLocation);\n\n        List&lt;DeliveryUnit&gt; allDeliveryUnits = objectMapper.readValue(\"[]\", new TypeReference&lt;List&lt;DeliveryUnit&gt;&gt;() {});\n        Mockito.when(deliveryUnitService.getAllDeliveryUnits()).thenReturn(allDeliveryUnits);\n\n        DeliveryCheckResponse deliveryCheckResponse = deliveryService.canDeliverToCustomer(4L);\n        DeliveryCheckResponse deliveryCheckResponseExpected = objectMapper.readValue(\"{\\\"customerProfile\\\":{\\\"customerid\\\":4,\\\"customername\\\":\\\"ohn Doe\\\",\\\"dateofbirth\\\":\\\"70-10-20\\\",\\\"email\\\":\\\"JD@mail\\\",\\\"contactnumber\\\":\\\"999-999\\\",\\\"address\\\":\\\"304 Alainis Parkway, Boylemouth, Virginia\\\",\\\"referralcodes\\\":[\\\"JGSDFS, FEFWEF, FWEFDF\\\"],\\\"createdDate\\\":\\\"Apr 12, 2024 12:54:08 PM\\\",\\\"updatedDate\\\":\\\"Apr 12, 2024 12:54:08 PM\\\"},\\\"requestWritten\\\":false,\\\"canDeliver\\\":false,\\\"weatherInfo\\\":{\\\"location\\\":{\\\"name\\\":\\\"Virginia Beach\\\",\\\"region\\\":\\\"Virginia\\\",\\\"country\\\":\\\"United States of America\\\",\\\"lat\\\":36.85,\\\"lon\\\":-75.98,\\\"tz_id\\\":\\\"America/New_York\\\",\\\"localtime_epoch\\\":1712906551,\\\"localtime\\\":\\\"2024-04-12 3:22\\\"},\\\"current\\\":{\\\"temp_c\\\":21.1,\\\"temp_f\\\":70.0,\\\"is_day\\\":0,\\\"condition\\\":{\\\"text\\\":\\\"Partly cloudy\\\",\\\"icon\\\":\\\"//cdn.weatherapi.com/weather/64x64/night/116.png\\\",\\\"code\\\":1003},\\\"wind_mph\\\":15.0,\\\"wind_kph\\\":24.1,\\\"wind_degree\\\":210,\\\"wind_dir\\\":\\\"SSW\\\",\\\"pressure_mb\\\":998.0,\\\"pressure_in\\\":29.48,\\\"precip_mm\\\":0.35,\\\"precip_in\\\":0.01,\\\"humidity\\\":84,\\\"cloud\\\":50,\\\"feelslike_c\\\":21.1,\\\"feelslike_f\\\":70.0,\\\"vis_km\\\":16.0,\\\"vis_miles\\\":9.0,\\\"uv\\\":1.0,\\\"gust_mph\\\":37.6,\\\"gust_kph\\\":60.5}}}\", DeliveryCheckResponse.class);\n        Assertions.assertEquals(deliveryCheckResponseExpected, deliveryCheckResponse);\n    }\n}\n</code></pre>"},{"location":"generate_automated_junit/#hows-this-different-from-co-pilot-and-ai-generated-tests","title":"How's this different from co-pilot and AI generated tests?","text":"<p>Unlogged.io stands out in the Java development tools space with several unique features. We offer runtime mocking, performance tracking, and real-time visual code coverage, which are not commonly available in similar products. </p> <p>Additionally, Unlogged offers specific capabilities for handling real-world data and scenarios, providing developers with tools to test and refine code under realistic conditions. </p> Features Unlogged Co-Pilot diffblue sapient ai codium AI IntelliJ AI Runtime mocking Yes No No No No No Bulk JUnit Test Generation Yes Yes Yes Yes Yes Yes Performance Tracking Yes No No No No No No Code Tests Yes No Yes Yes Yes No Code Generation using AI No Yes No No No Yes Real World Data/Scenarios Yes No No No No No Real Time Visual Code Coverage Yes No No No No No PR Documentation No Yes No No No Yes Convert from one Language to another No No Yes No No Yes"},{"location":"gutter/","title":"Gutter Icon States","text":"<p>Once you install Unlogged, for each method in your code base, you will see different gutter icons. The code, record, replay lifecycle revolves around these 6 gutter icons. </p> <p>Here are different gutter icons and what they mean</p> <p>Application Not Running with Unlogged</p> <p>This icon means that your application is not running with Unlogged. You can add the Unlogged dependency in your pom.xml or build.gradle, mvn clean or gradle clean and start debugging your application.</p> <p>Check Getting Started section to know how to add the dependency.</p> <p>Application Running with Unlogged</p> <p>Once you see this icon, it means that your application is running with Unlogged. Now, you can invoke any method inside your Java code using Direct Invoke or call http end points using Postman, Swagger or UI.</p> <p>Use Postman, Swagger in case you are accessing these methods through http end points. You can even use your UI to send data to your application. </p> <p>You can use <code>Direct Invoke</code> inside the plugin to call any Java method directly. This will save you a lot of time in debugging deep within your code. You can start debugging your methods right where it matters.</p> <p>Recording Available for methods</p> <p>Once you execute a method, using either Direct Invoke, Postman, or Swagger, you will see this icon. It indicates that Unlogged has recorded input and return values for the method. </p> <p>Click on the icon and you can check the recorded data</p> <p></p> <p>Execute Method</p> <p>If you make code changes after a recording is done for a method, you will see a bolt icon. That means you can now hot-relaod the code changes within this method and replay its previously recorded inputs.</p> <p>Note the code changes in getWeatherinfo in the above vs below code snippet.</p> <p></p> <p>Passing Case</p> <p>After your code changes, and once you execute the method, this icon tells you if the return value is same as before. </p> <p></p> <p>Failing Case</p> <p>After your code changes, and once you execute the method, this icon tells you if the return value is different from before. </p> <p></p> <p>Here is a cheat sheet that explains these gutter states in short.</p> <p></p>"},{"location":"java_replay_testing/","title":"Saving and running the Replays","text":"<p>You can save the replays and git push them to your repo so that your team mates can start using the replay tests you created.</p>"},{"location":"java_replay_testing/#types-of-replays","title":"Types of Replays","text":"<p>You can save and run the replays either in unit mode or integration mode. In unit mode, all the mocks inside a method are automatically saved and mapped with the replay.</p> <p>In integration mode, no mocks are applied.</p>"},{"location":"java_replay_testing/#assertions","title":"Assertions","text":"<p>When you click on save, we save them with one on one key value assertions. You can edit them later from library.</p>"},{"location":"java_replay_testing/#mocks","title":"Mocks","text":"<p>All the mocks needed for the replays are stored and mapped automatically to the replays. </p> <p>Replays and mockd with assertions are saved at the below location</p> <p><code>/YOUR MODULE DIRECTORY/src/test/resources/unlogged</code></p> <p></p>"},{"location":"java_replay_testing/#how-to-run-the-replays-in-ci","title":"How to run the Replays in CI?","text":"<p>While running the replay tests locally is important during development for rapid feedback, using a CI pipeline  enhances the overall development process by automating the testing and validation steps in a controlled and scalable environment. It ensures that the codebase is reliable and meets quality standards before changes are pushed to production.</p> <p></p>"},{"location":"java_replay_testing/#adding-the-dependency","title":"Adding the dependency","text":"mavengradle <pre><code>&lt;dependency&gt;\n  &lt;artifactId&gt;unlogged-sdk&lt;/artifactId&gt;\n  &lt;groupId&gt;video.bug&lt;/groupId&gt;\n  &lt;version&gt;LATEST&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>dependencies\n{\n    implementation 'video.bug:unlogged-sdk:LATEST'\n    annotationProcessor 'video.bug:unlogged-sdk:LATEST'\n}\n</code></pre>"},{"location":"java_replay_testing/#replays-like-unit-tests","title":"Replays like unit tests","text":"<p>Start by creating the following test class file <code>UnloggedTest.java</code> in your src/test/java directory</p> <pre><code>import io.unlogged.runner.UnloggedTestRunner;\nimport org.junit.runner.RunWith;\n\n@RunWith(UnloggedTestRunner.class)\npublic class UnloggedTest {\n\n}\n</code></pre> <p>and then run this simple command.</p> mavengradle <pre><code>mvn test\n</code></pre> <pre><code>./gradlew test\n</code></pre> <p>For Replay cases to be picked up from CLI you will need to add the following extra dependencies.</p> mavengradle <pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.platform&lt;/groupId&gt;\n        &lt;artifactId&gt;junit-platform-runner&lt;/artifactId&gt;\n        &lt;version&gt;1.10.0&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;junit&lt;/groupId&gt;\n        &lt;artifactId&gt;junit&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n</code></pre> <pre><code>dependencies\n{   \n    testImplementation 'junit:junit:4.12'\n    testRuntimeOnly 'org.junit.vintage:junit-vintage-engine:5.2.0'\n}\n</code></pre> <p>Tip</p> <p>Yep! This class has no methods since the replay tests will be based on <code>src/test/resources/unlogged/&lt;ClassName&gt;.json</code> files.</p>"},{"location":"java_replay_testing/#integration-testing-on-springboot-application","title":"Integration testing on Springboot application","text":"<p>For Springboot applications, customize the above tests as follows:</p> <pre><code>@RunWith(UnloggedTestRunner.class)\n@ComponentScan(\"&lt;spring.application.package.name&gt;\")\n@EnableAutoConfiguration\n@PropertySource(\nvalue = {\"config/application.yml\", \"config/application-dev.yml\"},\nfactory = UnloggedRunnerTest.YamlPropertySourceFactory.class) \n@TestPropertySource({\"classpath:application.properties\"})\n@WebAppConfiguration\npublic class UnloggedRunnerTest {\n\n    public static class YamlPropertySourceFactory implements PropertySourceFactory {\n        public YamlPropertySourceFactory() {\n        }\n\n    @Override\n    public PropertiesPropertySource createPropertySource(String name, EncodedResource encodedResource) throws IOException {\n            YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();\n            factory.setResources(encodedResource.getResource());\n            return new PropertiesPropertySource(encodedResource.getResource().getFilename(), factory.getObject());\n       }\n    }\n}\n</code></pre> <p>Remember!</p> <p>Remember to update <code>&lt;spring.application.package.name&gt;</code> to your package name, <code>config/application-dev.yml</code> to the config files you want to use. <code>UnloggedRunnerTest.YamlPropertySourceFactory.class</code> is for supporting yml files. Specify your test application properties inside <code>ApplicationProperties.class</code>.</p> <p><code>WebAppConfiguration</code> annotation is needed if there are any methods in starting class of the project that configure services, that cannot be enabled for integration tests. For example some configuration for Swagger or API monitoring. If these configurations are in a seperate file, then the annotation is not needed.</p> <p>With this, unlogged test runner will create as instance of the spring application context and execute the tests based on the beans created by spring.</p>"},{"location":"java_replay_testing/#test-and-coverage-reports-for-replays","title":"Test and Coverage Reports for Replays","text":"<p>Popular Test reports like <code>surefire</code> and Coverage reports like <code>JaCoCo</code> will pick up Replay cases readily. <code>mvn test</code> or <code>gradle test</code> or any commands to trigger reports will automatically include Replay cases as long as they are executed.</p>"},{"location":"liveview/","title":"Live View","text":"<p>Live View provides a sophisticated monitoring tool designed for Java developers, allowing them to observe the runtime behavior of applications in granular detail. This feature acts as a real-time diagnostic tool, presenting an immersive view into the execution of your code.</p>"},{"location":"liveview/#feature-highlights","title":"Feature Highlights","text":"<p>Real-Time Method Tracking: Live View offers a detailed visual representation of each method execution within your application, marked by the exact timestamp of occurrence. This feature operates entirely offline, ensuring that no code or data is transferred externally, thereby prioritizing privacy and security.</p> <p>Performance Analysis: With the Performance Wizard, developers can quantify the execution time of each method, measured in milliseconds. By selecting the time icon during a replay, the tool displays the duration each line of code took to execute, offering insights into potential bottlenecks.</p> <p>Efficient Debugging: hovering over any method in the Live View will reveal the input arguments and the resultant output, facilitating a quick and effective debugging process.</p> <p>Code Coverage Inspection: Clicking on the executed lines within a replay illuminates precisely which lines were engaged during the method's execution, enhancing code coverage analysis.</p>"},{"location":"liveview/#utilizing-replays","title":"Utilizing Replays","text":"<p>To initiate replays, developers can interact with their APIs through tools such as Postman, Swagger, or directly through the user interface. Additionally, invoking Java methods directly is supported. Replays begin populating in the Live View almost instantaneously, providing real-time feedback and analysis.</p> <p>This advanced feature set is designed to empower developers by offering an in-depth look at application performance and behavior, significantly aiding in optimization and debugging efforts.</p> <p></p>"},{"location":"logging_mode/","title":"Logging Mode","text":"<p>There are 3 modes to allow complete control over what should be recorded. This configuration allows the user to probe only some classes and methods that are of interest. </p>"},{"location":"logging_mode/#log-all-mode","title":"Log all mode","text":"<p><code>@Unlogged(unloggedMode = UnloggedMode.LogAll)</code></p> <ul> <li>This is the default state of SDK, and will be used if nothing is defined</li> <li>All methods will be probed by the SDK in this mode</li> </ul>"},{"location":"logging_mode/#log-annotated-only","title":"Log Annotated Only","text":"<p><code>@Unlogged(unloggedMode = UnloggedMode.LogAnnotatedOnly)</code></p> <ul> <li>It will log only classes and methods that are annotated using <code>@UnloggedClass</code> and <code>@UnloggedMethod</code></li> <li>This mode does not injects probes for non-annotated methods so they will not have any performance impact</li> <li>The counter of Unlogged annotation will be ignored, since any non-annotated method will not be logged.</li> </ul>"},{"location":"logging_mode/#log-annotated-with-children","title":"Log Annotated With Children","text":"<p><code>@Unlogged(unloggedMode = UnloggedMode.LogAnnotatedWithChildren)</code></p> <ul> <li>It will log classes and methods that are annotated using <code>@UnloggedClass</code> and <code>@UnloggedMethod</code> and the calls that they make to other methods.</li> <li>The counter of <code>@Unlogged</code> annotation will be used for downstream calls. A non-annotated downstream method will be logged only if the parent method is annotated, and both parent and child methods are to be logged from there frequency counter. </li> </ul>"},{"location":"logging_mode/#scenario","title":"Scenario:","text":"<ul> <li>Method-A is annotated with <code>@UnloggedMethod</code></li> <li>Method-B and C are non-annotated</li> <li>Method-A and B call method-C as a downstream call</li> <li>Process wide counter is set to 1.</li> </ul> <ul> <li>The following methods will be recorded based on unlogged mode and methods that are called.</li> </ul> UnloggedMode Method-A is called Method-B is called LogAll A and C are logged B and C are logged LogAnnotatedOnly A is logged nothing is logged LogAnnotatedWithChildren A and C are logged nothing is logged"},{"location":"mocking/","title":"Mocking","text":"<p>Traditionally, developers set up wiremock to mock APIs, and test containers to mock downstream services or database/redis calls. </p> <p>With one click, Unlogged lets you mock API, DB, downstream service calls </p> <p>and file operations, in runtime. </p>"},{"location":"mocking/#recorded-mocks","title":"Recorded Mocks","text":"<p>Unlogged automatically identifies the lines of code that can be mocked. </p> <p> A ghost icon will appear next to the identified lines. </p> <p>Use postman/swagger or Direct Invoke and the unlogged will show you the mocks with recorded <code>when</code> and <code>then</code> values. </p> <p></p>"},{"location":"mocking/#choices-of-mock-execution","title":"Choices of Mock Execution","text":"<p>Unlogged provides developers with a versatile mocking feature that allows for three distinct behaviors when handling method returns within tests. You can set a mock to execute its normal behavior, return a null value, or throw a designated exception. This flexibility supports various testing scenarios, enabling developers to thoroughly test software behavior under different conditions.</p>"},{"location":"mocking/#what-happens-underneath-when-you-mock","title":"What happens underneath when you mock?","text":"<p>The plugin informs the sdk to replace the line of code with its mocks. In rutime, the mocks get executed instead of actual code. </p> <p>Tip</p> <p>The mock gets executed when you call the method either from Postman/Swagger or Direct Invoke. </p> <p>Static or Same Class methods</p> <p>Note that the static methods or methods within the same class can't be mocked. You will NOT see the ghost  icon in such cases.</p>"},{"location":"saving/","title":"Saving and running the Replays","text":"<p>You can save the replays and git push them to your repo so that your team mates can start using the replay tests you created.</p>"},{"location":"saving/#types-of-replays","title":"Types of Replays","text":"<p>You can save and run the replays either in unit mode or integration mode. In unit mode, all the mocks inside a method are automatically saved and mapped with the replay.</p> <p>In integration mode, no mocks are applied.</p>"},{"location":"saving/#assertions","title":"Assertions","text":"<p>When you click on save, we save them with one on one key value assertions. You can edit them later from library.</p>"},{"location":"saving/#mocks","title":"Mocks","text":"<p>All the mocks needed for the replays are stored and mapped automatically to the replays. </p> <p>Replays and mockd with assertions are saved at the below location</p> <p><code>/YOUR MODULE DIRECTORY/src/test/resources/unlogged</code></p>"},{"location":"saving/#gif-needed-here","title":"GIF NEEDED HERE","text":""},{"location":"saving/#how-to-run-the-replays-in-ci","title":"How to run the Replays in CI?","text":"<p>While running the replay tests locally is important during development for rapid feedback, using a CI pipeline  enhances the overall development process by automating the testing and validation steps in a controlled and scalable environment. It ensures that the codebase is reliable and meets quality standards before changes are pushed to production.</p>"},{"location":"saving/#adding-the-dependency","title":"Adding the dependency","text":"mavengradle <pre><code>&lt;dependency&gt;\n  &lt;artifactId&gt;unlogged-sdk&lt;/artifactId&gt;\n  &lt;groupId&gt;video.bug&lt;/groupId&gt;\n  &lt;version&gt;0.3.9&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>dependencies\n{\n    implementation 'video.bug:unlogged-sdk:0.3.9'\n    annotationProcessor 'video.bug:unlogged-sdk:0.3.9'\n}\n</code></pre>"},{"location":"saving/#replays-like-unit-tests","title":"Replays like unit tests","text":"<p>Start by creating the following test class file <code>UnloggedTest.java</code> in your src/test/java directory</p> <pre><code>import io.unlogged.runner.UnloggedTestRunner;\nimport org.junit.runner.RunWith;\n\n@RunWith(UnloggedTestRunner.class)\npublic class UnloggedTest {\n\n}\n</code></pre> <p>and then run this simple command.</p> mavengradle <pre><code>mvn test\n</code></pre> <pre><code>./gradlew test\n</code></pre> <p>Tip</p> <p>Yep! This class has no methods since the replay tests will be based on <code>src/test/resources/unlogged/&lt;ClassName&gt;.json</code> files.</p>"},{"location":"saving/#integration-testing-on-springboot-application","title":"Integration testing on Springboot application","text":"<p>For Springboot applications, customize the above tests as follows:</p> <pre><code>@RunWith(UnloggedTestRunner.class)\n@ComponentScan(\"&lt;spring.application.package.name&gt;\")\n@EnableAutoConfiguration\n@PropertySource(\nvalue = {\"config/application.yml\", \"config/application-dev.yml\"},\nfactory = UnloggedRunnerTest.YamlPropertySourceFactory.class) \n@TestPropertySource({\"classpath:application.properties\"})\n@WebAppConfiguration\npublic class UnloggedRunnerTest {\n\n    public static class YamlPropertySourceFactory implements PropertySourceFactory {\n        public YamlPropertySourceFactory() {\n        }\n\n    @Override\n    public PropertiesPropertySource createPropertySource(String name, EncodedResource encodedResource) throws IOException {\n            YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();\n            factory.setResources(encodedResource.getResource());\n            return new PropertiesPropertySource(encodedResource.getResource().getFilename(), factory.getObject());\n       }\n    }\n}\n</code></pre> <p>Remember!</p> <p>Remember to update <code>&lt;spring.application.package.name&gt;</code> to your package name, <code>config/application-dev.yml</code> to the config files you want to use. <code>UnloggedRunnerTest.YamlPropertySourceFactory.class</code> is for supporting yml files. Specify your test application properties inside <code>ApplicationProperties.class</code>.</p> <p><code>WebAppConfiguration</code> annotation is needed if there are any methods in starting class of the project that configure services, that cannot be enabled for integration tests. For example some configuration for Swagger or API monitoring. If these configurations are in a seperate file, then the annotation is not needed.</p> <p>With this, unlogged test runner will create as instance of the spring application context and execute the tests based on the beans created by spring.</p>"},{"location":"saving/#code-coverage-reports","title":"Code Coverage Reports","text":"<p>Running <code>mvn test</code> or <code>./gradlew test</code> will generate <code>xml</code> reports that are stored at <code>${basedir}/target/surefire-reports</code></p>"},{"location":"selective_logging/","title":"Selective Logging","text":"<p>The SDK can be configured to define the frequency with which methods should be logged. This improves the performance impact of running user application with SDK significantly. The default behavior is to log all calls to a method.</p>"},{"location":"selective_logging/#logging-series","title":"Logging Series","text":"<p>When a frequency counter is defined for a method, then that method would be logged at that frequency. For example if a method is configured to be logged at <code>counter=2</code>, then it's 1<sup>st</sup>, 3<sup>rd</sup>, 5<sup>th</sup>, 7<sup>th</sup>, 9<sup>th</sup> ... call will be logged. More strictly, if a <code>counter \"c\"</code> is defined for a method then it's <code>(nc+1)<sup>th</sup> call</code> will be logged where n is a whole number.</p> <p>Live Window</p> <p>Direct invoke of a method will always work with any counter. But the call will show in live window only if that call of method was logged.</p>"},{"location":"selective_logging/#level-of-logging-configuration","title":"Level of logging configuration","text":"<p>This configuration can be defined at many levels of the code hierarchy. These are:</p>"},{"location":"selective_logging/#1-process-based-logging-counter","title":"1. Process based logging counter","text":"<p>A blanket counter can be applied to the process, that will apply to all methods until overridden. This can be done as an parameter to the <code>Unlogged</code> annotation. The parameter value needs to be a long passed as a string to the processor. An example with counter 10 is defined below.</p> <pre><code>package org.unlogged.demo.unloggedapplicaton;\n\nimport io.unlogged.Unlogged;\nimport org.springframework.boot.SpringApplication;\n\npublic class Application {\n\n    @Unlogged(counter = \"10\")\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>"},{"location":"selective_logging/#2-class-based-logging-counter","title":"2. Class based logging counter","text":"<p>A counter can be applied to the class, that will apply to all it's methods. This can be done as an parameter to the <code>UnloggedClass</code> annotation. The parameter value also needs to be a long passed as a string to the processor. An example with counter 10 is defined below.</p> <pre><code>package org.unlogged.demo.unloggedapplicaton;\n\nimport io.unlogged.UnloggedClass;\n\n@UnloggedClass(counter = \"10\")\npublic class temp {\n\n    public long sumRange(long n) {\n        long sum = (n*(n+1))/2;\n        return sum;\n    }\n}\n</code></pre>"},{"location":"selective_logging/#3-method-based-logging-counter","title":"3. Method based logging counter","text":"<p>A counter can be applied to an individual method. This can be done as an parameter to the <code>UnloggedMethod</code> annotation. The parameter value needs to be a long passed as a string to the processor. An example with counter 10 is defined below.</p> <pre><code>package org.unlogged.demo.unloggedapplicaton;\n\nimport io.unlogged.UnloggedMethod;\n\npublic class temp {\n\n    @UnloggedMethod(counter = \"10\")\n    public long sumRange(long n) {\n        long sum = (n*(n+1))/2;\n        return sum;\n    }\n}\n</code></pre>"},{"location":"selective_logging/#priority-order-of-frequency-counters","title":"Priority order of frequency counters","text":"<ul> <li>A method's logging counter can have conflicting rules. Then they take precedence based on the following order: <pre><code>process level &lt; class level &lt; method level\n</code></pre></li> <li>For example, a application can have <code>process counter=10</code>. It can have a class <code>StudentController</code> with <code>class counter=100</code>, and two methods <code>getAllStudents</code> with <code>method counter=1000</code> and <code>getExamData</code> with no method annotation. Then <code>getAllStudents</code> will have <code>counter=1000</code> and it will override the class and process wide counter. The <code>getExamData</code> will have the <code>counter=100</code>, from class level.</li> </ul>"},{"location":"selective_logging/#special-methods-and-there-logging","title":"Special Methods and there logging","text":"<p>Some methods are probed/unprobed based on logic outside of above rules. These rules override any other logic defined at other level.</p>"},{"location":"selective_logging/#1-always-probed-method","title":"1. Always Probed Method","text":"<p>Some method are always probed. These are:</p> <ul> <li>methods of an interface</li> <li>methods of a enum</li> <li>constructor method</li> <li>starting method of process (the <code>public static void main()</code> method)</li> </ul>"},{"location":"selective_logging/#2-never-probed-method","title":"2. Never Probed Method","text":"<p>The method with following names are never probed:</p> <ul> <li><code>equals</code></li> <li><code>hashCode</code></li> <li><code>onNext</code></li> <li><code>onSubscribe</code></li> <li><code>onError</code></li> <li><code>currentContext</code></li> <li><code>onComplete</code></li> <li>Also any abstract method is never probed.</li> </ul> <p>Deployment Strategy</p> <p>The selective logging is a recommended strategy for deploying your application with SDK in production and pre-production environments. There should be a moderate frequency counter process wide. Stable classes/methods that are called many times should have extremely high counter values. Experimental classes/methods should have a lower counter value to log a wider range of traffic.</p>"},{"location":"server/","title":"Unlogged Server","text":"<p>The unlogged server is a self-hosted service, that can be used with plugin and SDK. Deploy the production service with SDK and it will push the logs to unlogged server. Then the IntelliJ IDEA will download the test candidates, and the production traffic will be replayed locally.</p>"},{"location":"server/#deployment-from-local-file-system","title":"Deployment from local file system","text":"<ul> <li>The server can be deployed without a minio and S3 configuration. All files will be stored in the local file system. </li> </ul>"},{"location":"server/#docker-deployment","title":"Docker Deployment","text":"<ul> <li>To deploy the server from docker run the following commands:</li> </ul> <pre><code># create a docker volume \ndocker volume create unlogged_volume\n\n# run the docker container\ndocker run -dp 8123:8123 \\\n-v unlogged_volume:/usr/src/app/local-session \\\nghcr.io/unloggedio/unlogged_server:latest\n</code></pre>"},{"location":"server/#docker-compose-deployment","title":"Docker-compose Deployment","text":"<ul> <li>The server can be deployed using docker compose. An example docker-compose file is as follows:</li> </ul> <pre><code>version: '2'\n\nservices:\n  unlogged_server:\n    image: ghcr.io/unloggedio/unlogged_server:latest\n    ports:\n      - \"8123:8123\"\n    volumes:\n      - unlogged_volume:/usr/src/app/local-session\n\nvolumes:\n  unlogged_volume:\n    external: true\n</code></pre> <ul> <li>Create a volume using <code>docker volume create unlogged_volume</code></li> <li>Run the container using <code>docker compose -f path_to_file up -d</code></li> </ul>"},{"location":"server/#jar-deployment","title":"Jar Deployment","text":"<ul> <li>The jar can be downloaded from here.</li> <li>The command to run from JAR is: <pre><code>java -jar unlogged_server.jar\n</code></pre></li> </ul>"},{"location":"server/#deployment-with-minio-server","title":"Deployment with minio server","text":""},{"location":"server/#docker-compose-approach","title":"Docker Compose Approach","text":"<ul> <li>The server can be deployed with a minio instance. This is a sample docker-compose file for the same: <pre><code>version: '2'\n\nservices:\n  unlogged_server:\n    image: ghcr.io/unloggedio/unlogged_server:latest\n    ports:\n      - \"8123:8123\"\n    environment:\n      - spring.profiles.active=minio\n      - cloud.bucketName=session-logs\n      - cloud.endpoint=http://minio:9000\n      - cloud.aws.region.static=ap-south-1\n      - cloud.aws.credentials.access-key=minio_user\n      - cloud.aws.credentials.secret-key=minio_password\n    networks:\n      - unlogged_network\n    volumes:\n      - unlogged_volume:/usr/src/app/local-session\n\n  minio:\n    image: minio/minio\n    container_name: minio\n    ports:\n      - \"9000:9000\"\n    command: server /data\n    environment:\n      - MINIO_ROOT_USER=minio_user\n      - MINIO_ROOT_PASSWORD=minio_password\n    networks:\n      - unlogged_network\n    volumes:\n      - unlogged_volume:/usr/src/app/local-session\n\nnetworks:\n  unlogged_network:\n    driver: bridge\n\nvolumes:\n  unlogged_volume:\n    external: true\n</code></pre></li> </ul>"},{"location":"server/#deployment-with-a-s3-bucket","title":"Deployment with a S3 bucket","text":"<p>A S3 bucket needs to created for storing the logs.</p>"},{"location":"server/#creating-a-s3-bucket","title":"Creating a S3 bucket.","text":"<ul> <li>Create a private S3 bucket in AWS. This step is optional, since the server will create a bucket by itself, if a bucket with the given name in region is not found.</li> <li>To use the server following environment variables are needed:<ol> <li><code>bucket_name</code>: Name of the s3 bucket</li> <li><code>bucket_region_url</code>: This is the URL of s3 region. For example <code>https://s3.eu-west-1.amazonaws.com</code></li> <li><code>bucket_region</code>: This is region of S3 bucket. For example: eu-west-1.</li> <li>To get the <code>access_key</code> and <code>secret_key</code> go to the security credentials of you account and create an access key.</li> </ol> </li> </ul>"},{"location":"server/#deploying-the-server","title":"Deploying the server","text":"<p>The server can be deployed using docker or the jar file. It can be done on both a private pc for personal testing and an instance of EC2 with public IP for company wide deployment.</p>"},{"location":"server/#docker-deployment_1","title":"Docker Deployment","text":"<ul> <li>To deploy the server from docker run the following commands:</li> </ul> <pre><code># create a docker volume \ndocker volume create unlogged_volume\n\n# run the docker container\ndocker run -dp 8123:8123 \n-v unlogged_volume:/usr/src/app/local-session\n-e spring.profiles.active=minio\n-e cloud.bucketName=bucket_name\n-e cloud.endpoint=bucket_region_url\n-e cloud.aws.region.static=bucket_region\n-e cloud.aws.credentials.access-key=access_key\n-e cloud.aws.credentials.secret-key=secret_key\nghcr.io/unloggedio/unlogged_server:latest\n</code></pre>"},{"location":"server/#docker-compose-deployment_1","title":"Docker-compose Deployment","text":"<ul> <li>The server can be deployed using docker compose. An example docker-compose file is as follows:</li> </ul> <pre><code>version: '2'\n\nservices:\n  unlogged_server:\n    image: ghcr.io/unloggedio/unlogged_server:latest\n    ports:\n      - \"8123:8123\"\n    volumes:\n      - unlogged_volume:/usr/src/app/local-session\n    environment:\n      - spring.profiles.active=minio\n      - cloud.bucketName=bucket_name\n      - cloud.endpoint=bucket_region_url\n      - cloud.aws.region.static=bucket_region\n      - cloud.aws.credentials.access-key=access_key\n      - cloud.aws.credentials.secret-key=secret_key\n\nvolumes:\n  unlogged_volume:\n    external: true\n</code></pre> <ul> <li>Create a volume using <code>docker volume create unlogged_volume</code></li> <li>Run the container using <code>docker compose -f path_to_file up -d</code></li> </ul>"},{"location":"server/#deployment-from-jar","title":"Deployment from JAR","text":"<ul> <li>The jar can be downloaded from here.</li> <li>To deploy the service using jar use the following command:</li> </ul> <pre><code>java -jar -Dspring.profiles.active=minio \\\n    -Dcloud.bucketName=bucket_name \\\n    -Dcloud.endpoint=bucket_region_url \\\n    -Dcloud.aws.region.static=bucket_region \\\n    -Dcloud.aws.credentials.access-key=access_key \\\n    -Dcloud.aws.credentials.secret-key=secret_key \\\n    unlogged_server.jar\n</code></pre>"},{"location":"server/#verifying-the-status-of-deployed-service","title":"Verifying the status of deployed service","text":"<ul> <li>If deployed on local machine go to <code>http://localhost:8123/session/ping</code></li> <li>If deployed on an EC2 instance go to <code>http://public_ip:8123/session/ping</code></li> </ul>"},{"location":"server/#docker-registries","title":"Docker Registries","text":"<p>The unlogged docker image is available on the following registries:</p> <ul> <li>Github GHCR: <code>ghcr.io/unloggedio/unlogged_server:latest</code></li> </ul>"},{"location":"server/#hardware-requirements","title":"Hardware Requirements","text":"<ol> <li> <p>The smallest server on AWS that will work with unlogged server is something like <code>t2.micro</code>. It would work with one session uploading logs and 5 users concurrently using it. It's system requirements are:</p> <ul> <li>Number of vCPU: 1</li> <li>Memory: 1 GiB</li> <li>Disk Space: 30 GiB (type gp3)</li> <li>Network Performance: Low to Moderate</li> </ul> </li> <li> <p>A recommended system that would work with a higher throughput of logs will be a little larger like <code>t2.xlarge</code>. It would work with 4 session uploading logs and 20 users concurrently using it. It's system requirements are:</p> <ul> <li>Number of vCPU: 4</li> <li>Memory: 16 GiB</li> <li>Disk Space: 120 GiB (type gp3)</li> <li>Network Performance: Moderate</li> </ul> </li> </ol>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#installing-the-plugin","title":"Installing the Plugin","text":"<ul> <li>IntelliJ IDEA --&gt; Preferences --&gt; Plugins --&gt; Marketplace</li> <li>Search for Unlogged in the marketplace &amp; Install</li> </ul>"},{"location":"setup/#adding-the-dependency","title":"Adding the dependency","text":"mavengradle <pre><code>&lt;dependency&gt;\n  &lt;artifactId&gt;unlogged-sdk&lt;/artifactId&gt;\n  &lt;groupId&gt;video.bug&lt;/groupId&gt;\n  &lt;version&gt;LATEST&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>dependencies\n{\n    implementation 'video.bug:unlogged-sdk:LATEST'\n    annotationProcessor 'video.bug:unlogged-sdk:LATEST'\n}\n</code></pre> <p>Sync your project once so that the Unlogged dependency is downloaded from maven repository.</p>"},{"location":"setup/#adding-the-annotation","title":"Adding the annotation","text":"<p>To start recording method input and return values - add <code>@Unlogged</code> annotation just above your main method.</p> <p>Here is an example.</p> <pre><code>   @Unlogged\n   public static void main(String[] args) {\n        SpringApplication.run(JwtDemoApplication.class, args);\n    }\n</code></pre>"},{"location":"setup/#clean-and-debug","title":"Clean, and Debug!","text":"mavengradle <pre><code>mvn clean\n</code></pre> <pre><code>gradle clean\n</code></pre> <p>Start your application in debug mode to call any java function directly.</p>"},{"location":"setup/#disabling-unlogged","title":"Disabling Unlogged","text":"<p>You can disable unlogged either in compile or runtime.</p>"},{"location":"setup/#compile-time","title":"Compile Time","text":"mavengradle <pre><code>mvn package -Dunlogged.disable\n</code></pre> <pre><code>./gradlew build -Dunlogged.disable\n</code></pre>"},{"location":"setup/#run-time","title":"Run Time","text":"<p>Update the <code>annotation</code> on top of your main method.</p> <pre><code>@Unlogged(enable = false)\n</code></pre> <p>Remember</p> <p>Note that when you disable the annotation in runtime, the logging probes are still added to your code. But they won't log anything, since the <code>enable</code> flag is set to <code>false</code></p>"}]}